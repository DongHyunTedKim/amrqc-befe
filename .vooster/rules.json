{
  "rules": [
    {
      "type": "prd",
      "content": "# Product Requirements Document\n\n## 1. Executive Summary\n\nAMR QC 솔루션은 스마트폰에서 발생하는 실시간 센서 스트리밍 데이터를 로컬 서버에 저장하고, 웹 클라이언트(WebView)에서 타임라인 형태로 시각화·조회할 수 있는 경량 통합 수집 시스템이다. 사용자는 `.exe` 파일 한 번 실행만으로 서버와 웹 클라이언트를 자동 기동하며, 스마트폰은 서버 주소를 입력해 즉시 연동된다. 본 솔루션은 복잡한 설정 없이 빠른 데이터 수집·모니터링 환경을 제공해 연구·품질관리 효율을 대폭 향상시킨다.\n\n## 2. Problem Statement\n\n- 스마트폰 센서 시계열 데이터를 손쉽게 수집·보관·시각화할 수 있는 경량 로컬 솔루션이 부재\n- 클라우드 의존 없이 오프라인 환경에서도 데이터 분석이 필요\n- 연구원·QA 담당자는 데이터 누락·동기화 오류로 품질관리 비용 증가\n\n## 3. Goals and Objectives\n\n- Primary Goal: 실시간 스마트폰 센서 데이터를 원클릭 로컬 서버에 저장·시각화\n- Secondary Goals:\n  - 오프라인 환경 완전 지원\n  - 설치·설정 5 분 이내 완료\n  - 데이터 시각화 초당 30 fps 수준의 부드러운 타임라인 제공\n- Success Metrics:\n  - 최초 실행~수집 개시까지 평균 2 분 이하\n  - 일간 활성 사용자(DAU) 90% 이상 재사용\n  - 데이터 수집 누락률 < 0.5%\n  - 평균 응답 시간 < 200 ms (REST)\n\n## 4. Target Audience\n\n### Primary Users\n\n- 연구소·품질관리(QC) 엔지니어\n  - 센서 데이터 수집 필요\n  - 로컬 보안 정책으로 클라우드 사용 제한\n- 대학·기업 연구원\n  - 프로토타입 실험 데이터 신속 확보\n  - 코드·서버 운용 경험이 부족\n\n### Secondary Users\n\n- 고객사: AMR제조업체\n- 프로젝트 대표: 본 개발 프로젝트 일정 관리, 프로젝트 퀄리티 관리\n- 프로젝트 매니저: 본 개발 프로젝트 일정 관리\n\n## 5. User Stories\n\n- `.exe`를 실행해 모든 서비스가 자동 시작되길 원한다.\n- QC 엔지니어로서 서버와 클라이언트웹뷰가 실행되면 가장 먼저 스마트폰에서 해당 서버에 접속하기 위해 URL을 QR형태로 제공해야 한다. 그 후에 테스트하고자 하는 AMR에 붙어있는 QR코드로 해당 디바이스의 ID를 식별하고, 해당 디바이스ID에서 들어오는 데이터들을 보여주기 위한 클라이언트 웹뷰 탭에서 해당 디바이스에 대한 데이터를 실시간 모니터링, 사후 조회하고 싶다.\n- 연구원으로서 수집된 데이터를 타임라인 그래프로 확인하고 싶다. 그래야 이상치를 즉시 발견할 수 있다.\n- 관리자로서 업로드된 센서데이터를 그대로 다운로드하고 싶다. 그래야 재가공·재학습에 활용할 수 있다.\n\n## 6. Functional Requirements\n\n### Core Features\n\n1. 서버 애플리케이션\n   - `.exe` 실행 시 Node.js 서버 및 브라우저 WebView 자동 기동\n   - WebSocket 서버: 스마트폰에서 전송된 센서 패킷 실시간 수신\n   - REST API:\n     - `GET /data`: 센서 메타 조회\n     - `GET /data/download`: 지정된 기간의 센서 데이터를 파일(CSV 등)로 다운로드\n   - 데이터 저장: SQLite `data.db`에 시계열·메타 데이터 기록\n   - IP 표시: 콘솔에 `http://<local_ip>:8000` 자동 출력\n   - Acceptance Criteria:\n     - `.exe` 실행 후 10 초 이내 서버 Listening\n     - 패킷 유실률 0.5% 이하\n2. 웹 클라이언트\n   - Next.js export 정적 빌드, WebView 로드\n   - 타임라인 뷰:\n     - 리스트 모드: 기록별 타임스탬프·센서값 요약\n\n- 그래프 모드: 시계열 그래프, 확대/축소·구간 선택\n- 디바이스별 타임라인: 각 AMR 장비(deviceId)별로 분리된 타임라인 뷰 제공, 디바이스 선택 및 전환 기능 포함\n  - 데이터 다운로드: 조회 중인 타임라인의 센서 데이터를 파일로 다운로드하는 버튼 제공\n  - REST 연동: 실시간 요청/응답 로딩 표시\n  - Acceptance Criteria:\n    - 그래프 렌더링 지연 < 200 ms\n\n## 7. Non-Functional Requirements\n\n- 성능: 동시 5 대 스마트폰 스트림 시 CPU 40% 이하, 메모리 500 MB 이하\n- 보안: 로컬 네트워크 내 접근, CSRF·XSS 방어\n- 사용성: 2 단계 이하 메뉴 구조, 키보드·마우스 모두 지원\n- 확장성: 플러그인 형태로 추가 센서 타입 모듈화\n- 호환성: Windows 10/11 64-bit, Chrome 최신\n\n## 8. Technical Considerations\n\n- Architecture: Electron Shell + Node.js 서버, Next.js 정적 파일 포함 단일 패키지\n- Integration: 스마트폰 앱(별도)에서 WebSocket/REST 호출\n- Data Model:\n  - SensorTable(id, deviceId, ts, sensorType, valueJson)\n- Dependencies: `ws`, `express`, `better-sqlite3`, `chart.js`\n- 배포: 단일 설치파일 생성\n\n## 9. Success Metrics and KPIs\n\n- 추가 작업 없이 최대한 빠르게 MVP 완성\n\n## 10. Timeline and Milestones\n\n- Task 1: 전체 구조 설정, DB 설계\n- Task 2–3: WebSocket 센서 수신 구현\n- Task 4: Next.js 웹뷰 구현 및 타임라인 렌더링\n- Task 5: 센서 데이터 다운로드 기능 구현 (API 및 클라이언트 버튼)\n- Task 6: .exe 패키징, 자동 실행 테스트\n- Task 7: 전체 통합 테스트, 문서화\n- Task 8: 스마트폰 샘플앱 연결 테스트\n- Task 9: 마무리 및 고객 전달용 패키징\n\n## 11. Risks and Mitigation\n\n- 오프라인 환경 장애 시 지원 지연 → 로컬 로그 제공\n- 기술 의존성(Node.js 버전) → LTS 버전 고정, 자동 업데이트 테스트\n\n## 12. Future Considerations\n\n- AI 기반 이상 탐지 플러그인 (on-premise LLM)(선택)\n",
      "writedAt": "2025-07-28T10:25:47.800Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n\n- **프로젝트 개요**  \n  AMR QC 솔루션은 Windows 환경에서 `.exe` 한 번 실행으로 Electron 셸이 Node.js 서버와 WebView(Next.js 정적 빌드)를 자동 기동하여 스마트폰 센서 스트리밍 데이터를 로컬에 저장·시각화하는 경량 통합 수집 시스템입니다. WebSocket과 REST API를 통해 데이터를 처리하며, SQLite에 시계열·메타 데이터를 기록합니다.\n\n- **핵심 기술 스택**  \n  Electron, Node.js(Express, ws), better-sqlite3, Next.js, Chart.js, Windows 10/11 64-bit\n\n- **주요 기술 목표**  \n  • 실시간 센서 패킷 유실률 < 2%  \n  • REST 평균 응답 시간 < 200 ms  \n  • 타임라인 뷰 렌더링 지연 < 200 ms  \n  • 동시 5 대 스트림 시 CPU ≤ 40%, 메모리 ≤ 500 MB\n\n- **주요 가정**  \n  • 대상 OS는 Windows 10/11 64-bit  \n  • Node.js LTS 버전 고정  \n  • 스마트폰 앱은 표준 JSON 포맷으로 WebSocket/REST 호출  \n  • 최대 동시 5 대 센서 스트림\n\n## 2. Tech Stack\n\n| Category              | Technology / Library    | Reasoning (선택 이유)                       |\n| --------------------- | ----------------------- | ------------------------------------------- |\n| Desktop Shell         | Electron                | `.exe` 자동 실행, Node.js 서버·WebView 통합 |\n| Backend Runtime       | Node.js (LTS)           | 풍부한 생태계, 경량 서버 구현, 배포 용이    |\n| Web Framework         | Next.js (export static) | 정적 빌드 WebView 로딩, SEO·빌드 속도 우수  |\n| Real-time 통신        | ws                      | 경량 WebSocket 구현, 실시간 패킷 수신       |\n| REST API              | Express                 | 간단한 라우팅·미들웨어 구조, 빠른 개발      |\n| Database              | better-sqlite3          | 동기식 쿼리, 낮은 오버헤드, 파일 기반 관리  |\n| Visualization         | Chart.js                | 타임라인 그래프·확대·축소 기능 지원         |\n| Packaging & Installer | electron-builder        | Windows Installer(.exe) 자동 생성           |\n| 유틸리티              | winston                 | 로깅·모니터링                               |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n\n- Electron Shell  \n  • Node.js 서버 실행  \n  • WebView(Next.js) 로드\n- Node.js Server  \n  • Express 기반 REST API (`/data`, `/data/download`)  \n  • ws 기반 WebSocket 서버  \n  • SQLite(`data.db`) 연결 및 쿼리\n- Web Client (Next.js Static)  \n  • 타임라인 뷰(리스트·그래프 모드)  \n  • 시계열 데이터 다운로드 기능\n- Smartphone Client  \n  • WebSocket 센서 데이터 스트리밍  \n  • REST 데이터 조회\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n  Mobile[스마트폰 앱] -->|WebSocket/REST| Server[Node.js 서버]\n  Electron[Electron Shell]\n  Electron --> Server\n  Electron --> WebView[WebView (Next.js)]\n  Server --> DB[SQLite 데이터베이스]\n```\n\n- 스마트폰 앱이 WebSocket/REST로 Node.js 서버와 통신\n- Electron Shell이 서버와 WebView를 동시에 기동\n- 서버는 SQLite에 데이터를 저장\n- WebView는 REST/WebSocket으로 서버 데이터를 조회·시각화\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**\n\n- **빠른 구현 우선**: MVP 단계에서는 빠른 개발을 위해 기능별 모듈(`routes/sensor.js`) 중심으로 구현합니다.\n- **공통 컴포넌트**: 재사용 가능한 모듈은 `shared/`에 분리합니다.\n\n**Universal File & Folder Structure**\n\n```\n/\n├── app/                      # Electron main process\n│   ├── main.js\n│   └── preload.js\n├── server/                   # Node.js 서버\n│   ├── routes/               # 기능별 API 라우트\n│   ├── services/             # (선택) 초기에는 라우트 파일에 로직 통합 가능\n│   ├── db.js                 # 데이터베이스 설정 및 연결\n│   └── index.js\n├── client/                   # Next.js 정적 클라이언트\n│   ├── pages/\n│   ├── components/\n│   ├── public/\n│   └── next.config.js\n├── shared/                   # 공통 모듈\n│   ├── utils/\n│   └── types/\n├── data.db                   # SQLite 데이터베이스\n├── package.json\n└── installer/                # electron-builder 설정\n```\n\n### Data Flow & Communication Patterns\n\n- **Client-Server Communication**:  \n  • WebSocket: sensor streaming (이벤트 기반)  \n  • REST: 메타조회(`/data`), 데이터 다운로드(`/data/download`)\n- **Database Interaction**:  \n  • better-sqlite3 동기식 트랜잭션, prepared statements\n- **외부 서비스 통합**: 없음 (로컬 전용)\n- **실시간 통신**: ws 라이브러리, ping/pong 체크\n- **데이터 동기화**:  \n  • WebSocket 메시지 → in-memory 버퍼 → SQLite 기록  \n  • 업로드 완료 후 메타 DB 업데이트\n\n## 4. Performance & Optimization Strategy\n\n- better-sqlite3 prepared statement 사용으로 DB쓰기 최적화\n- Chart.js requestAnimationFrame 기반 렌더링\n- WebSocket 메시지 배치 처리(batch insert)\n- 정적 자원(WebView) 캐싱, lazy loading는 지금 당장 도입하기보다 백업플랜으로 준비\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n\n- **Core Infrastructure**: Electron + Node.js 기본 프로젝트 구조\n- **Essential Features**: WebSocket 서버, REST API(조회, 다운로드), SQLite 스키마\n- **Basic Security**: (현재 범위에서는 특별한 보안 요건 없음)\n- **Development Setup**: 개발 환경·CI 설정(GitHub Actions)\n- **Timeline**: 4주\n\n### Phase 2: Feature Enhancement\n\n- **Advanced Features**: 타임라인 뷰(그래프 확대/축소), QR 코드 URL 제공\n- **Performance Optimization**: 동시 5 스트림 부하 테스트, 리소스 튜닝\n\n- **Monitoring Implementation**: winston 기반 로깅, 간단 대시보드\n- **Timeline**: 6주\n\n### Phase 3: Scaling & Optimization\n\n- **Scalability Implementation**: 플러그인 아키텍처 모듈화\n- **Advanced Integrations**: AI 이상 탐지 플러그인 기본 구조\n- **Enterprise Features**: 로컬 감사 로그, 권한 관리\n- **Compliance & Auditing**: 보안 감사 보고서, 자동화 테스트\n- **Timeline**: 8주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n\n- **Technology Risks**: Node.js 이벤트 루프 병목 → 메시지 배치 처리로 완화\n- **Performance Risks**: SQLite 동시 쓰기 충돌 → 트랜잭션·Lock 최소화\n- **Integration Risks**: 스마트폰 OS별 포맷 불일치 → 표준 JSON 스펙 제공\n\n### Project Delivery Risks\n\n- **Timeline Risks**: Electron·Next.js 숙련도 부족 → 초기 PoC로 기술 검증\n- **Resource Risks**: 인력 이탈 시 개발 공백 → 지식 공유를 위해 문서화\n- **Quality Risks**: 테스트 커버리지 부족 → **핵심 기능 E2E 테스트 우선 확보**, 점진적 커버리지 확대\n- **Deployment Risks**: Windows 버전 호환성 → 10/11 자동 테스트 환경 구성\n- **Contingency Plans**:  \n  • 수동 설치 가이드 제공\n  • 점진적 고도화: `services`, `repositories` 등 상세 레이어 분리는 Phase 2에서 코드 복잡성이 증가할 때 점진적으로 리팩토링합니다.\n\n---\n\n_상기 TRD는 PRD 요건을 기반으로 최소화된 기술 스택과 도메인 구분 전략을 적용하여 오버엔지니어링을 방지하며, 빠른 출시와 장기 유지보수를 동시에 고려한 설계안입니다._\n",
      "writedAt": "2025-07-28T10:25:47.800Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-28T10:25:47.800Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-28T10:25:47.801Z"
    },
    {
      "type": "task-dependency-awareness",
      "content": "# 태스크 의존성 및 후속 영향 고려 가이드라인\n\n## 핵심 원칙\n\n현재 수행 중인 태스크가 후속 태스크들에 미치는 영향을 항상 고려하여 작업 범위를 적절히 조정합니다.\n\n## 작업 계획 시 필수 검토사항\n\n### 1. 후속 태스크 영향 분석\n**REQUIRED ACTIONS:**\n- 현재 태스크 완료 후 다음에 수행될 태스크들의 요구사항 검토\n- 현재 작업이 후속 태스크에서 필요한 기반 작업을 포함하는지 확인\n- 중복 작업을 방지하기 위한 작업 범위 조정\n\n### 2. 태스크 경계 설정\n**금지사항:**\n- ❌ 후속 태스크의 핵심 업무를 현재 태스크에서 미리 수행\n- ❌ 명시적으로 요청되지 않은 후속 기능 구현\n- ❌ 다음 단계의 상세 구현을 현재 단계에서 완성\n\n**허용사항:**\n- ✅ 후속 태스크의 성공을 위한 최소한의 기반 구조 마련\n- ✅ 인터페이스나 타입 정의 등 공통 기반 요소 준비\n- ✅ 후속 작업을 위한 확장 가능한 구조 설계\n\n### 3. 작업 범위 결정 프로세스\n\n```markdown\n## 태스크 의존성 체크리스트\n\n### 현재 태스크: [Task ID]\n**주요 목표:** [현재 태스크의 핵심 목표]\n\n### 후속 태스크 검토:\n- [ ] [다음 태스크 ID]: [해당 태스크가 현재 작업에 의존하는 부분]\n- [ ] [그 다음 태스크 ID]: [영향받을 수 있는 부분]\n\n### 작업 범위 조정:\n**포함할 항목:**\n- [후속 태스크 성공을 위해 현재 단계에서 반드시 필요한 기반 요소]\n\n**제외할 항목:**\n- [후속 태스크에서 다뤄야 할 구체적 구현사항]\n\n**경계선 판단:**\n- [애매한 경우 사용자에게 확인 요청]\n```\n\n## 실무 적용 예시\n\n### 예시 1: DB 스키마 설계 태스크\n**현재 태스크:** T-004 (DB 스키마 설계)\n**후속 태스크:** T-006 (API 구현)\n\n**적절한 범위:**\n- ✅ 기본 테이블 구조 설계\n- ✅ API에서 사용할 기본 쿼리 패턴 고려\n- ❌ 실제 API 엔드포인트 구현 (T-006 영역)\n\n### 예시 2: 컴포넌트 설계 태스크\n**현재 태스크:** T-003 (기본 컴포넌트 구조)\n**후속 태스크:** T-005 (상세 기능 구현)\n\n**적절한 범위:**\n- ✅ 컴포넌트 인터페이스 정의\n- ✅ Props 타입 정의\n- ❌ 모든 상세 기능 로직 구현 (T-005 영역)\n\n## 의사결정 가이드라인\n\n### 포함 여부 판단 기준\n1. **의존성 체크:** 후속 태스크가 이 작업 없이 시작 가능한가?\n2. **핵심 책임:** 이 작업이 현재 태스크의 주요 목표에 포함되는가?\n3. **사용자 의도:** 사용자가 명시적으로 \"미리 하지 말라\"고 했는가?\n\n### 애매한 경우 대응\n- 사용자에게 명확히 확인 요청\n- 최소한의 기반만 마련하고 상세 구현은 후속 태스크에 위임\n- 작업 범위를 명확히 문서화하여 투명성 확보\n\n## 커뮤니케이션 가이드\n\n### 작업 시작 전\n```\n현재 [Task ID] 작업을 시작합니다.\n후속 태스크 [Next Task IDs]와의 연관성을 고려하여,\n다음 범위로 작업을 진행하겠습니다:\n\n**포함할 작업:**\n- [항목들]\n\n**후속 태스크로 위임할 작업:**\n- [항목들]\n\n이 범위로 진행해도 괜찮을까요?\n```\n\n### 작업 완료 후\n```\n[Task ID] 작업이 완료되었습니다.\n후속 태스크 [Next Task ID]를 위해 다음 기반이 준비되었습니다:\n- [준비된 기반 요소들]\n\n다음 태스크에서 수행할 주요 작업:\n- [후속 태스크의 핵심 업무들]\n```\n\n이 가이드라인을 통해 각 태스크가 명확한 경계를 유지하면서도 전체 프로젝트의 연속성을 보장할 수 있습니다.",
      "writedAt": "2025-07-29T06:58:30.000Z"
    }
  ]
}
